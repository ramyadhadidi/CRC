<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: IDEBUGGER_SHELL_INSTRUMENTOR Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>IDEBUGGER_SHELL_INSTRUMENTOR Class Reference</h1><!-- doxytag: class="IDEBUGGER_SHELL_INSTRUMENTOR" --><code>#include &lt;debugger-shell.H&gt;</code>
<p>
<a href="classIDEBUGGER__SHELL__INSTRUMENTOR-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDEBUGGER__SHELL__INSTRUMENTOR.html#c47a5391c6a6fb3ede7d1cb115e27e79">InsertBreakpointBefore</a> (INS ins, BBL bbl, <a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a> order, const std::string &amp;message)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDEBUGGER__SHELL__INSTRUMENTOR.html#48943cf959da92f0d7df6ebc69687f16">InsertBreakpointAfter</a> (INS ins, BBL bbl, <a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> ipoint, <a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a> order, const std::string &amp;message)=0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Some tools may need to define their own analysis routine that stops at a debugger breakpoint. Such tools can define their own class, which derives from <a class="el" href="classIDEBUGGER__SHELL__INSTRUMENTOR.html">IDEBUGGER_SHELL_INSTRUMENTOR</a>. Pass a pointer to that object to <a class="el" href="structDEBUGGER__SHELL__ARGS.html#adc9a5b4873983ea506f07e605b988eb">DEBUGGER_SHELL_ARGS::_overrideInstrumentation</a>.<p>
Most tools do not need to override the default instrumenation, so most tools need not use this interface. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="48943cf959da92f0d7df6ebc69687f16"></a><!-- doxytag: member="IDEBUGGER_SHELL_INSTRUMENTOR::InsertBreakpointAfter" ref="48943cf959da92f0d7df6ebc69687f16" args="(INS ins, BBL bbl, IPOINT ipoint, CALL_ORDER order, const std::string &amp;message)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual VOID IDEBUGGER_SHELL_INSTRUMENTOR::InsertBreakpointAfter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BBL&nbsp;</td>
          <td class="mdname" nowrap> <em>bbl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The debugger shell calls this method to insert a "then" instrumentation call to an analysis routine that stops at a debugger breakpoint _after_ an instruction. The default instrumenation looks like this. Tools that implement this method should insert similar instrumentation:<p>
VOID InsertBreakpointAfter(INST ins, BBL bbl, IPOINT ipoint, CALL_ORDER order, const std::string &amp;message) { INS_InsertThenCall(ins, ipoint, (AFUNPTR)TriggerBreakpointAfter, IARG_CALL_ORDER, order, IARG_CONTEXT, IARG_INST_PTR, IARG_THREAD_ID, IARG_PTR, message.c_str(), IARG_END); }<p>
VOID TriggerBreakpointAfter(CONTEXT *ctxt, ADDRINT pc, THREADID tid, const char *message) { std::ostringstream os; os &lt;&lt; message &lt;&lt; "\n"; os &lt;&lt; "Breakpoint triggered after instruction at 0x" &lt;&lt; std::hex &lt;&lt; pc;<p>
PIN_ApplicationBreakpoint(ctxt, tid, FALSE, os.str()); }<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>Insert the instrumentation after this instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bbl</em>&nbsp;</td><td>The basic block containing <em>ins</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipoint</em>&nbsp;</td><td>Tells whether to instrument IPOINT_AFTER or IPOINT_TAKEN_BRANCH. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>The instrumentation call order to use for the instrumentation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>String telling why the breakpoint is triggered. The string is allocated in permanent storage, so the client can pass it directly to an analysis routine. If the debugger shell removes instrumenation, it will also deallocate this string. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c47a5391c6a6fb3ede7d1cb115e27e79"></a><!-- doxytag: member="IDEBUGGER_SHELL_INSTRUMENTOR::InsertBreakpointBefore" ref="c47a5391c6a6fb3ede7d1cb115e27e79" args="(INS ins, BBL bbl, CALL_ORDER order, const std::string &amp;message)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual VOID IDEBUGGER_SHELL_INSTRUMENTOR::InsertBreakpointBefore           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BBL&nbsp;</td>
          <td class="mdname" nowrap> <em>bbl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The debugger shell calls this method to insert a "then" instrumentation call to an analysis routine that stops at a debugger breakpoint _before_ an instruction. The default instrumenation looks like this. Tools that implement this method should insert similar instrumentation:<p>
VOID InsertBreakpointBefore(INST ins, BBL bbl, CALL_ORDER order, const std::string &amp;message) { INS_InsertThenCall(ins, IPOINT_BEFORE, (AFUNPTR)TriggerBreakpointBefore, IARG_CALL_ORDER, order, IARG_CONTEXT, IARG_THREAD_ID, IARG_UINT32, static_cast&lt;UINT32&gt;(RegSkipOne), IARG_PTR, message.c_str(), IARG_END); }<p>
VOID TriggerBreakpointBefore(CONTEXT *ctxt, THREADID tid, UINT32 regSkipOne, const char *message) { ADDRINT skipPc = PIN_GetContextReg(ctxt, static_cast&lt;REG&gt;(regSkipOne)); ADDRINT pc = PIN_GetContextReg(ctxt, REG_INST_PTR); if (skipPc == pc) return<p>
PIN_SetContextReg(ctxt, static_cast&lt;REG&gt;(regSkipOne), pc); PIN_ApplicationBreakpoint(ctxt, tid, FALSE, message); }<p>
See the method <a class="el" href="classIDEBUGGER__SHELL.html#7b75c4827e4a147dc4d734ed5104bf1d">IDEBUGGER_SHELL::GetSkipOneRegister()</a> for the register number to use for <em>RegSkipOne</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>Insert the instrumentation before this instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bbl</em>&nbsp;</td><td>The basic block containing <em>ins</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>The instrumentation call order to use for the instrumentation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>String telling why the breakpoint is triggered. The string is allocated in permanent storage, so the client can pass it directly to an analysis routine. If the debugger shell removes instrumenation, it will also deallocate this string. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>debugger-shell.H</ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Dec 15 03:24:17 2009 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
